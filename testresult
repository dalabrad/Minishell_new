──────────────────────────────────────────────────────────────────────────────────────────────────
│ #   │ Descripción                       │ Comando(s)                                  │ OUT   ││
──────────────────────────────────────────────────────────────────────────────────────────────────
│ 1   │ export + env: crea y lee VAR1      │ export VAR1=hola; env | grep VAR1          │ ✅    ││
│ 2   │ export con espacios (VAR2)         │ export VAR2="con espacios"; env | grep VAR2│ ✅    ││
│ 3   │ reasignación VAR1                  │ export VAR1=adios; env | grep VAR1         │ ✅    ││
│ 4   │ unset TMPVAR                       │ export TMPVAR=test; env | grep '^TMPVAR='… │ ✅    ││
│ 5   │ pwd / cd / pwd                     │ pwd; cd /; pwd                             │ ✅    ││
│ 6   │ cd .. y pwd                        │ cd ..; pwd                                 │ ✅    ││
│ 7   │ cd noexiste (status)               │ cd noexiste; echo \$?                      │ ✅    ││
│ 8   │ cd . y pwd                         │ cd .; pwd                                  │ ✅    ││
│ 9   │ cd (HOME) y pwd                    │ cd; pwd                                    │ ✅    ││
│ 10  │ /bin/ls ok (status)                │ /bin/ls >/dev/null; echo \$?               │ ✅    ││
│ 11  │ /bin/ls fallo (status)             │ /bin/ls noexiste; echo \$?                 │ ✅    ││
│ 12  │ /bin/echo hola mundo               │ /bin/echo hola mundo                       │ ✅    ││
│ 13  │ echo "hola mundo"                  │ echo "hola mundo"                          │ ✅    ││
│ 14  │ echo con espacios extra            │ echo "hola     con   espacios"             │ ✅    ││
│ 15  │ echo texto con tubería literal     │ echo "cat lol.c | grep main"               │ ✅    ││ 
│ 16  │ variable X sin comillas            │ export X=42; echo \$X                      │ ✅    ││
│ 17  │ variable X con comillas dobles     │ export X=42; echo "\$X"                    │ ✅    ││
│ 18  │ variable X dentro de simples       │ export X=42; echo '\$X'                    │ ✅    ││
│ 19  │ echo \$ (vacío en bash)            │ echo \$                                    │ ✅    ││
│ 20  │ echo "\$"                          │ echo "\$"                                  │ ✅    ││
│ 21  │ comilla simple sin cerrar (error)  │ echo '\$                                   │ ✅    ││
│ 22  │ relative path ./rel42.sh           │ ./rel42.sh                                 │ ✅    ││
│ 23  │ /bin/ls simple                     │ /bin/ls | head -n 3                        │ ✅    ││
│ 24  │ retorno ok y error                 │ /bin/ls >/dev/null; echo \$?; /bin/ls noex…│ ✅    ││
│ 25  │ /bin/ls -l (argumentos)            │ /bin/ls -l >/dev/null                      │ ✅    ││
│ 26  │ /bin/ls -la /tmp                   │ /bin/ls -la /tmp >/dev/null                │ ✅    ││
│ 27  │ echo hola                          │ echo hola                                  │ ✅    ││
│ 28  │ echo -n "sin salto"                │ echo -n "sin salto"                        │ ✅    ││
│ 29  │ echo "hola" "mundo"                │ echo "hola" "mundo"                        │ ✅    ││
──────────────────────────────────────────────────────────────────────────────────────────────────

✅ echo $ → línea vacía.

✅ echo '$' → $

✅ echo "$" → $

✅ echo $? → 0 (o último status).

✅ echo '$?' → $? literal.

✅ echo "$?" → 0 (expansión dentro de comillas dobles).echo <mari

✅ echo hola <mari

✅ cat mari

✅ cat <mari

✅ echo x >a >b

✅ <in echo ok

✅ <result <mari <meri

✅ >result4

<in

✅ <<

✅ # Crea y sobrescribe
echo "uno" >a.txt
echo "dos" >a.txt
cat a.txt    # → solo "dos"

✅ # Last wins → escribe en b.txt, no en a.txt
echo "a" >a.txt >b.txt
cat b.txt

✅ # Append
echo "line1" >>c.txt
echo "line2" >>c.txt
cat c.txt    # → line1 + line2

✅ cat <infile || echo hola
cmd arg > infile1 arg arg >infile1
echo bai > result echo ez >result

✅ echo bai > result echo ez >result2 echo jaja >result3
echo yas >> result >> yes >>result2 echo yis >>result3

✅ echo $$$$$USERyes$USER
11639761163976uxmancis

✅ ls | " HOLA " | Vane << >> hola, len = 30

✅ "Tener historial funcional de lo que hemos escrito en terminal, 
flechita arriba - flechita abajo para navegar por historial"

✅ "Acceder a archivos en distintas carpetas
Buscar y ejecutar ejecutable correcto (pwd, cd .., variable PATH, rutas relativas y absolutas)
- Ruta relativa desde ubicación actual inc/minishell.h
- Ruta absoluta: home/etc/uxmancis/Desktop/inc/minishell.h"

✅ "Recepción de señal: máx 1 variable global.
1) Señales ctrl-C, ctrl-D, ctrl-\ ...
*En la variable global podemos ir guardando la señal que tenemos que devolver (uso común de variable global)"
"No interpretar: comillas sin cerrar, caracteres especiales no especificados (\ ; )
\n --> \ hace que pille caracter regular (\n = caracter regular = salto de línea).
*En este caso en el proyecto minishell no tenemos que interpretar la contrabarra ""\n"", es decir, no existen caracteres regulares.
\t

- Comillas sin cerrar: en bash se queda esperando --> ""Error, comillas sin cerrar"".
- \ contrabarra --> ""Error"", o, no interpretarlo como \, si no que como un caracter más, sin ninguna funcionaldiad adicional de caracteres regulares.
- ; punto coma; en bash cuando termina un comando ejecuta el siguiente. P.ej.: echo ""hola\\nadios"" ; echo uxue (en bash. Para acceder a shell bash, escribir ""bash"" en la terminal). Nosotros en Minishell proyecto --> ""Error, caracter no válido"" cuando haya un ;.

*Se trata de caracteres que en bash tienen X funcionalidad, pero que en nuestro proyecto Minishell no se nos exige que implantemos."
"‘ → no debe interpretar metacaracteres en la secuencia entrecomillada

✅ Básicos
echo 'hola $USER'             # hola $USER
echo "hola $USER"             # hola <usuario>
echo '""hola $USER""'         # ""hola $USER""
echo ""                       # (línea en blanco)
echo ''                       # (línea en blanco)

✅ Concatenación/vars
echo "$USER$USER"             # <usuario><usuario>
echo $USER$USER               # <usuario><usuario>
echo "$?x"                    # <status>x

✅ Casos límite de $
echo $                        # $ (literal si no hay nombre)
echo "$"                      # $
echo "$1"                     # (si no soportas posicionales -> cadena vacía / literal según diseño)

✅ scapes simples (si los contemplas)
echo "\$USER"                 # $USER (si tratas '\' dentro de dobles)

✅ echo '"comillas dobles"'      # "comillas dobles"

✅ Redirecciones (con espacios y comillas)
echo hola > "a b.txt"         # crea/overwrite
cat "a b.txt"                 # hola

✅ echo mundo >> 'a b.txt'       # append
cat "a b.txt"                 # hola\nmundo

✅ Heredoc (si lo tienes):
echo "\$USER" → $USER

✅ cat <<EOF con hola $USER → hola vlorenzo
cat <<'EOF' con hola $USER → hola $USER
echo '""hola $USER""' → ""hola $USER""

✅ Poderes: 
 ' > $ Si $ = metacaracter, pero si antes de $ ', entonces $ no es un metacaracter = no cumple su función de metacaracter, actúa como caracter normal.
 '  vs. "", según cuál llega antes

✅ *Pueden darse distintas combinaciones"
"“ → no debe interpretar metacaracteres en la secuencia entrecomillada
 Excepción: $

✅ Con "" $ es el único metacaracter"
"Implementar redirecciones:
< redirigir input (entrada). 
P.ej.: cat Makefile = cat < Makefile
cat result.txt                   =              cat < result.txt                =            < result.txt cat

> redirigir output (salida) me lo metes en X archivo. Si no existe, me lo creas el archivo.

<< recibir delimitador, leer input fuente actual (...)
<< es ""heredoc""
Estructura de cadena que incluye <<: COMANDO ARG << INDICADOR_FINAL_HEREDOC
Comprobación en terminal:
cat << vane ->enter
g ->enter
f ->enter
d ->enter
uxue ->enter
ver lo que sucede
P.ej.: cat<<hola|cat>>out

*Si lo hacemos con cat << $USER --> veremos que no expande


>> redirigir output en modo append.
Diferencia con "">"", este "">>"" no pisa lo que hay dentro, lo pone a continuación
Comprobarlo en terminal poniendo los siguientes: 
echo hola > result.txt
echo adios > result.txt
echo hola >> result.txt
*Igualmente, si no existe el archivo lo crea

Otros comandos a entender: 
1. cat << hola
2. echo hola | cat > doc1.txt
3. echo holaaa| < doc1.txt cat > doc1.txt
4. echo holaaa| < result3.txt cat | cat > doc1.txt
5. echo holaaa < result3.txt cat | cat > doc1.txt
"
"Implementar pipes. Output de 1 comando → se conecta a través de pipe con input de siguiente comando.
> fork: subprocesos --> programa devuelve 0 Success, 1 x, -1, ...
gestión procesos, proyecto pipex (Pipe = tubería)

Comprobaciones en terminal:
1) echo hola | cat Makefile vs. echo hola | cat
2) echo hola | wc -l
3) echo hola | echo adios --> se la pela 3 el output del primer comando, así que lo omite"
Gestionar variables de entorno ($ seguidos de caracteres)
"$?: estado del úlltimo comando que se ha ejecutado.
Comprobación en terminal: echo $? --> 
127 (Error de comando)
0 Success 
(...)
$? no se trata de una variable de entorno (no está en env) = es un número que nosotros tenemos que ir almancenando.

Para esto de $? parece que se usa lo de la variable global

Gestionar $? expandirse (...)

$ variables de entorno = puedes acceder a ella desde cualquier ruta/subruta

*En la terminal pon ""env"" para ver el total de variables de entorno
.env = archivo con variables de entorno para una ruta en particular, si estás fuera de esta ruta no pedes acceder a estas variables de entorno.
>ARG=""4 67 3 87 23""; ./push_swap $ARG | ./checker_OS $ARG

$USER --> existe en ""env"" USER? En caso de ser así, sustituye el valor $USER por lo que ponga.
En resumen,cuando ponga $XXX, sustituye e $XXX por el valor asignado a XXX en el listado de variablles de entorno, ponga lo que ponga. Es decir, si en env XXX es igual a otro valor, cuando pongamos $USER se referirá al que se especifique en env.

Expandir = sustituir $USER por el valor definido en env
$USER = uxmancis, la sustitución = acción de expandir."
"ctrl-C ctrl-D ctrl-\ → funcionar como en bash. Interactivo:
ctrl-C imprime una nueva entrada en una línea nueva. (teclado ctrl C)
Nueva línea (p.ej.: cierra/salida de proceso ongoing. Como cuando ponemos solo cat, que se queda esperando).

ctrl-D termina el shell.
1) mata el proceso en el que estamos (p.ej.:: si estamos en cat y waiting, se sale del cat).
2) si no hay proceso ongoing (p.ej.: cat), nos salimos de la shell.

ctrl-\ no hace nada. (ctrl 4) wtf Ander me ha dicho essto, wtf, comenta que puede variar ssegún teclado, no lo sabe tampoco"
"*readline --> checkear flags en Makefile ya existente
*execve es el que ejecuta el resto de comandos (p.ej.: ls, cat, ...) --> todos estos comandos tenemos que interpretarlos dentro de los args. Una vez lo hayamos identificado, se lo pasamos al execve
Al execve hay que pasarle no ""ls"" como cadena, lo qu hay que pasarle es la ruta en la que está el binario. Binario = archivo que ejecuta el comando. 
env --> vemos variables de entorno, entre las que se encuentra PATH. En Path, dividir todo lo que. leemos, almacearlo quizás en algún lado, 
split por : para separar los distintos paths.
P.ej.: (antes)
PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/munki:/Users/uxmancis/.brew/bin
split
/usr/local/bin
le podríammos añaddir nuestra cadena y así podríamos comprobar si la ruta existe. P.ej.: 
/usr/local/bin/cat
   **Access(función autorizada) --> se lo puedes pasar para ver si la ruta existe o no, en base a su retorno. 0 Success y 1 no existe (por ejemplo, no sé realmente qué devuelve access).
*Por ejemplo, una vez identifiquemos un comando, podemos probar el 100% de rutas del PATH , y ver dónde se encuentra el binario del comando a ejecutar en particular. Podríamoss con el access tratar de probarlos todos, hasta enccontrar aquella rutaque sí existe y ver que esa es la que sí nos vale. Así, esa ruta es la que le pasamos al execve.
Cuando execve va a ejecutar un comando
if pid == 0 --> 

**

Implementar buil-ins
echo → (while isspace ++) imprime todo lo que viene luego 
*echo -n yepa vs. echo yepa (-n incluye sal
Comrpobación en terminal: echo yepa | cat -e vs. echo -n yepa | cat -e (salto de línea)
echo normal incluye salto de línea

cd → navegación por carpetas

pwd → ruta

export --> para crear variables de entorno
export hola=uxue --> env vemos nueva variable de entorno
Si solo ponemos export hola (sin asignar el valor), esta variable no figura en ""env"", si no que deberemos poner ""export"", donde nos figurará el listado de variables de entorno sin valor asignado.
También podemos hacer varias a la vez: export a=1, b=2, c=3

unset --> Comprobación en terminal: unset a --> se elimina la variable de entorno direcctamente, deja de figurar en env, y tampoco en export (en caso de que no tuviera valor asignado).
*Solo unset no hace nada

env : muestra las variables de entorno que tienen valor asignado

exit → se cierra la terminal
P.ej.: exit 5 --> definimos el número/output/salida con el que hacemos exit. Si hacemos echo $ después, la terminal nos mostrará 5."


